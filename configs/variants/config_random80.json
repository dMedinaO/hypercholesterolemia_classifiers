{
  "task": "binary_classification",
  "target": "MSPH",
  "models": {
    "LogisticRegression": {
      "enabled": true,
      "init_params": {
        "max_iter": 5000,
        "solver": "liblinear"
      },
      "param_grid": {
        "C": [
          0.1,
          1.0,
          10.0
        ],
        "penalty": [
          "l2"
        ],
        "class_weight": [
          null,
          "balanced"
        ]
      },
      "notes": "Baseline interpretable classifier. Keep grid small for low-N."
    },
    "LinearDiscriminantAnalysis_svd": {
      "enabled": true,
      "backend": "sklearn",
      "class_name": "LinearDiscriminantAnalysis",
      "init_params": {},
      "param_grid": {
        "solver": [
          "svd"
        ],
        "shrinkage": [
          null
        ]
      },
      "notes": "LDA with solver=svd. shrinkage is not supported with svd."
    },
    "LinearDiscriminantAnalysis_lsqr_shrink": {
      "enabled": true,
      "backend": "sklearn",
      "class_name": "LinearDiscriminantAnalysis",
      "init_params": {},
      "param_grid": {
        "solver": [
          "lsqr"
        ],
        "shrinkage": [
          null,
          "auto"
        ]
      },
      "notes": "LDA with solver=lsqr; shrinkage supported (useful in low-N)."
    },
    "QuadraticDiscriminantAnalysis": {
      "enabled": true,
      "init_params": {},
      "param_grid": {
        "reg_param": [
          0.0,
          0.1,
          0.3
        ]
      },
      "notes": "QDA can overfit; reg_param regularizes covariance estimates."
    },
    "KNeighborsClassifier": {
      "enabled": true,
      "init_params": {},
      "param_grid": {
        "n_neighbors": [
          3,
          5,
          7,
          11
        ],
        "weights": [
          "uniform",
          "distance"
        ],
        "p": [
          1,
          2
        ]
      },
      "notes": "Highly sensitive to scaling; evaluate with/without scaler later."
    },
    "SVC_linear": {
      "enabled": true,
      "backend": "sklearn",
      "class_name": "SVC",
      "init_params": {
        "kernel": "linear",
        "probability": true
      },
      "param_grid": {
        "C": [
          0.1,
          1.0,
          10.0
        ],
        "class_weight": [
          null,
          "balanced"
        ]
      },
      "notes": "Margin-based baseline; probability=True for probability outputs (still assess calibration)."
    },
    "SVC_rbf": {
      "enabled": true,
      "backend": "sklearn",
      "class_name": "SVC",
      "init_params": {
        "kernel": "rbf",
        "probability": true
      },
      "param_grid": {
        "C": [
          0.1,
          1.0,
          10.0
        ],
        "gamma": [
          "scale",
          "auto"
        ],
        "class_weight": [
          null,
          "balanced"
        ]
      },
      "notes": "Non-linear SVM; keep grid small to reduce overfitting risk."
    },
    "RandomForestClassifier": {
      "enabled": true,
      "init_params": {
        "n_estimators": 500,
        "n_jobs": -1
      },
      "param_grid": {
        "max_depth": [
          null,
          3,
          5,
          10
        ],
        "min_samples_leaf": [
          1,
          2,
          5
        ],
        "max_features": [
          "sqrt",
          0.5,
          1.0
        ],
        "class_weight": [
          null,
          "balanced"
        ]
      },
      "notes": "Tree ensemble baseline; scaling not required."
    },
    "ExtraTreesClassifier": {
      "enabled": true,
      "init_params": {
        "n_estimators": 500,
        "n_jobs": -1
      },
      "param_grid": {
        "max_depth": [
          null,
          3,
          5,
          10
        ],
        "min_samples_leaf": [
          1,
          2,
          5
        ],
        "max_features": [
          "sqrt",
          0.5,
          1.0
        ],
        "class_weight": [
          null,
          "balanced"
        ]
      },
      "notes": "High-variance model; useful to compare vs RF."
    },
    "GradientBoostingClassifier": {
      "enabled": true,
      "init_params": {},
      "param_grid": {
        "n_estimators": [
          200,
          400
        ],
        "learning_rate": [
          0.03,
          0.1
        ],
        "max_depth": [
          2,
          3
        ],
        "subsample": [
          1.0
        ]
      },
      "notes": "Classic boosting (no class_weight). Use resampling strategies later if needed."
    },
    "HistGradientBoostingClassifier": {
      "enabled": true,
      "init_params": {},
      "param_grid": {
        "max_depth": [
          2,
          3,
          5
        ],
        "learning_rate": [
          0.03,
          0.1
        ],
        "max_iter": [
          200,
          400
        ],
        "l2_regularization": [
          0.0,
          0.1
        ]
      },
      "notes": "Fast boosting with regularization; good low-N stress test."
    },
    "GaussianNB": {
      "enabled": true,
      "init_params": {},
      "param_grid": {
        "var_smoothing": [
          1E-12,
          1E-10,
          1E-8
        ]
      },
      "notes": "Simple generative baseline; often surprisingly strong."
    },
    "XGBClassifier": {
      "enabled": false,
      "backend": "xgboost",
      "init_params": {
        "objective": "binary:logistic",
        "eval_metric": "logloss",
        "n_jobs": -1
      },
      "param_grid": {
        "n_estimators": [
          300,
          600
        ],
        "max_depth": [
          2,
          3,
          4
        ],
        "learning_rate": [
          0.03,
          0.1
        ],
        "subsample": [
          0.8,
          1.0
        ],
        "colsample_bytree": [
          0.8,
          1.0
        ],
        "reg_lambda": [
          1.0,
          5.0
        ]
      },
      "notes": "Optional. Keep conservative to avoid overfitting and excessive tuning."
    },
    "LGBMClassifier": {
      "enabled": false,
      "backend": "lightgbm",
      "init_params": {
        "objective": "binary",
        "n_jobs": -1
      },
      "param_grid": {
        "n_estimators": [
          300,
          600
        ],
        "num_leaves": [
          15,
          31
        ],
        "learning_rate": [
          0.03,
          0.1
        ],
        "subsample": [
          0.8,
          1.0
        ],
        "colsample_bytree": [
          0.8,
          1.0
        ],
        "reg_lambda": [
          0.0,
          1.0
        ]
      },
      "notes": "Optional. Conservative grid to keep comparisons fair."
    }
  },
  "preprocessing": {
    "imputation": {
      "enabled": true,
      "strategies": [
        {
          "name": "none",
          "notes": "Use when dataset is complete-case (STRICT)."
        },
        {
          "name": "median",
          "params": {},
          "notes": "Median imputation for numeric variables. Must be fit on training folds only."
        }
      ]
    },
    "scaling": {
      "enabled": true,
      "strategies": [
        {
          "name": "none",
          "notes": "No scaling. Appropriate for tree-based models; still evaluate for robustness."
        },
        {
          "name": "standard",
          "params": {},
          "notes": "StandardScaler (z-score). Recommended for LR/SVM/KNN/PCA."
        },
        {
          "name": "robust",
          "params": {},
          "notes": "RobustScaler (median/IQR). More stable under outliers."
        },
        {
          "name": "maxabs",
          "params": {},
          "notes": "MaxAbsScaler. Included because it was used previously; compare systematically."
        }
      ]
    },
    "pca": {
      "enabled": true,
      "strategies": [
        {
          "name": "off",
          "notes": "No PCA. Baseline."
        },
        {
          "name": "on",
          "params_grid": {
            "n_components": [
              0.9,
              0.95,
              0.99
            ],
            "whiten": [
              false
            ],
            "svd_solver": [
              "full"
            ]
          },
          "notes": "PCA with variance retention. Fit on training folds only. Use after scaling."
        },
        {
          "name": "on",
          "params_grid": {
            "n_components": [
              3,
              5,
              7,
              9
            ],
            "whiten": [
              false
            ],
            "svd_solver": [
              "full"
            ]
          },
          "notes": "PCA with fixed component count (interpretability / stability check)."
        }
      ],
      "constraints": {
        "apply_only_if_scaled": true,
        "scalers_allowed": [
          "standard",
          "robust",
          "maxabs"
        ],
        "do_not_apply_for_models": [
          "RandomForestClassifier",
          "ExtraTreesClassifier",
          "GradientBoostingClassifier",
          "HistGradientBoostingClassifier",
          "XGBClassifier",
          "LGBMClassifier"
        ],
        "behavior_on_forbidden": "skip",
        "notes": "Avoid PCA for tree-based methods by default."
      }
    }
  },
  "resampling": {
    "enabled": true,
    "strategies": [
      {
        "name": "none",
        "notes": "No resampling. Baseline."
      },
      {
        "name": "undersample",
        "backend": "imblearn",
        "class_name": "RandomUnderSampler",
        "params_grid": {
          "sampling_strategy": [
            1.0,
            0.75
          ],
          "replacement": [
            false
          ]
        },
        "notes": "Random undersampling of majority class. Applied ONLY to training folds."
      },
      {
        "name": "smote",
        "backend": "imblearn",
        "class_name": "SMOTE",
        "params_grid": {
          "sampling_strategy": [
            1.0,
            0.75
          ],
          "k_neighbors": [
            3,
            5
          ]
        },
        "notes": "SMOTE oversampling. Applied ONLY to training folds. Use with scaling."
      },
      {
        "name": "smoteenn",
        "backend": "imblearn",
        "class_name": "SMOTEENN",
        "params_grid": {
          "sampling_strategy": [
            1.0,
            0.75
          ],
          "smote_k_neighbors": [
            3,
            5
          ]
        },
        "notes": "SMOTE + ENN cleaning. More aggressive; good stress test for robustness."
      }
    ],
    "constraints": {
      "apply_only_on_training_folds": true,
      "requires_imblearn": true,
      "on_failure": "fallback_to_none",
      "notes": [
        "Resampling must be performed within the CV loop/pipeline (train folds only) to avoid leakage.",
        "If a resampling strategy fails (e.g., too few minority samples for SMOTE), fallback_to_none to keep the run going."
      ]
    }
  },
  "validation": {
    "enabled": true,
    "seed_grid": {
      "enabled": true,
      "n_seeds": 30,
      "base_seed": 42,
      "seeds": [
        478163327,
        1122456590,
        198888238,
        1648070629,
        2013803541,
        1130931295,
        1092773876,
        330267354,
        624025999,
        505971449,
        189471860,
        1956584712,
        180971984,
        1794556993,
        1646993365,
        1185818180,
        2002859153,
        1210909078,
        722441195,
        1239291411,
        1309741490,
        1095861064,
        1193372385,
        291055688,
        1339447843,
        399093796,
        1707422099,
        266442816,
        343096468,
        1403726111
      ],
      "notes": "Fixed list of 100 unique seeds stored in the config to ensure exact reproducibility."
    },
    "strategies": [
      {
        "name": "random_split_80_20",
        "backend": "sklearn",
        "class_name": "train_test_split",
        "params_grid": {
          "test_size": [
            0.2
          ],
          "stratify": [
            false
          ]
        },
        "use_seed_grid": true,
        "notes": "Single holdout per seed; included as sensitivity analysis."
      }
    ],
    "constraints": {
      "classification_only": true,
      "apply_resampling_train_only": true,
      "apply_imputation_scaling_pca_within_folds": true,
      "recommended_primary_strategy": "kfold",
      "notes": [
        "Avoid relying on a single 80/20 split because test sets are small in low-N.",
        "Seeds are fixed and recorded for reproducibility.",
        "All preprocessing (imputation, scaling, PCA) and resampling must be fit/applied using training folds only."
      ]
    },
    "reporting": {
      "store_fold_predictions": true,
      "store_models": false,
      "metrics": [
        "roc_auc",
        "pr_auc",
        "brier",
        "mcc",
        "accuracy",
        "balanced_accuracy",
        "precision",
        "recall",
        "f1",
        "tn",
        "fp",
        "fn",
        "tp"
      ],
      "thresholds": {
        "enabled": true,
        "values": [
          0.5
        ],
        "notes": "Default threshold 0.5 for reporting. Clinical threshold selection can be performed later."
      }
    }
  },
  "defaults": {
    "random_state": 42,
    "probability_outputs_required": true
  },
  "version": "0.1.1"
}
